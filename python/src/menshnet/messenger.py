"""
MQTT/HTTP based messaging module for client.

All requests go through the HTTP interface for authentication, 
MQTT is used to receive events from running gimels.
"""
import sys
import atexit
import queue
import threading


import paho.mqtt.client as mqtt
import requests
import json


SETUP_CMD      = "https://menshnet.online/api/setup"
DISCONNECT_CMD = "https://menshnet.online/api/disconnect"
START_CMD      = "https://menshnet.online/api/start"
STOP_CMD       = "https://menshnet.online/api/stop"
HEARTBEAT_CMD  = "https://menshnet.online/api/heartbeat"

class Messenger:

    def _on_shutdown(self):
        try:
            r = requests.post(DISCONNECT_CMD, json={ 'apiKey': self.apiKey })
            if r.status_code != 200:
                logging.error("disconnect %s" % r.content.decode())
        except:
            # send and forget
            pass

    def __init__(self, apiKey, logger):
        self.mqttc = None
        self.mt = None
        self.apiKey = apiKey
        self.subscribe_inflight = {}
        self.logger = logger

        # handle inbound events and route to user supplied
        # endpoint
        self.topic_handlers = {}

        atexit.register(self._on_shutdown)

    def __del__(self):
        self._on_shutdown()
        atexit.unregister(self._on_shutdown)

    def _on_message(self, client, userdata, msg):
        #self.logger.debug("Inbound message %s %s" % (msg.topic,msg.payload))
        handler = self.topic_handlers.get(msg.topic)
        if callable(handler):
            jobj = json.loads(msg.payload.decode())
            handler(jobj) 
        else:
            self.logger.warning("Unhandled topic %s" % msg.topic)

    def _on_subscribe(self, client, userdata, mid, granted_qos):
        self.logger.debug("on subscribe mid=%s" % str(mid))
        if mid in self.subscribe_inflight:
             # set event that we have subscribed to topic 
             self.subscribe_inflight[mid].set()

    def _on_connect(self, client, userdata, flags, rc):
        self.logger.debug("on connect rc=%d" % rc)
        

    ## public interface

    

    def heartbeat(self):
        r = requests.post(HEARTBEAT_CMD, json={
                "apiKey": self.apiKey 
            })
        if r.status_code != 200:
            print(r.content)
            self.logger.error("Unable to send heartbeat to remote server")    

    def register(self, topic, handler):
        "bind a callback to a mqtt topic"
        # subscribe, wait for confirmation
        mid = self.mqttc.subscribe(topic)[1]
        self.subscribe_inflight[mid] = threading.Event() 
        self.subscribe_inflight[mid].wait()
        del self.subscribe_inflight[mid]

        # assign topic handler
        self.topic_handlers[topic] = handler

    def unregister(self, topic):
        self.mqttc.unsubscribe(topic)
        del self.topic_handlers[topic]

    def start(self, apiKey, name, resId, event_topic, config):
        """
        post message to gatway to kick off pipeline
        """
        r = requests.post(START_CMD, json={ 
            "apiKey": apiKey,
            "name": name,
            "resId": resId,
            "event_topic": event_topic,
            "config": config
        })
        if r.status_code == 400:
            raise ValueError(r.content.decode())
        elif r.status_code != 200:
            raise RuntimeError(r.content.decode()) 
        

    def setup(self, timeout=15):
        """
        Setup communication for receinging events and sending
        commands.    

        apiKey: apiKey which is generated by menshnet and is available on the
                user dashboard page.

        on_ready: if supplied then setup will not block rather it will
                  call on_ready when messenger is ready to process 
                  commands. Otherwise this call shall block.

        Return:
            A list of pipeline names that teh end user dfined in thier git repo. 
        """
        pipeline_names = []
        # validate apikey
        r = requests.post(SETUP_CMD, json={
            "apiKey": self.apiKey 
        })
        if r.status_code != 200:
            raise ConnectionRefusedError(r.content)
        data = json.loads(r.content)
        pipeline_names = data['result']['names']

        if len(pipeline_names) == 0:
            self.logger.warning("There are no configured pipeline names for you to use!")

        f = "apikey validated connecting to mqtt broker pipeline_names=%s" 
        self.logger.debug(f % str(pipeline_names))
        
        self.mqttc = mqtt.Client(transport="websockets")
        self.mqttc.on_connect = self._on_connect
        self.mqttc.on_message = self._on_message
        self.mqttc.on_subscribe = self._on_subscribe

        self.mqttc.connect('menshnet.online',9001,60)

        #NOTE: do not use the loop_start, very wierd problems
        # using that. Instead we will run our own network
        # thread.
        self.mt = threading.Thread(target=self.mqttc.loop_forever)
        self.mt.daemon = True
        self.mt.start()           

        return pipeline_names



if __name__ == '__main__':
    import sys
    import logging

    apiKey = sys.argv[1]
    logging.basicConfig(stream=sys.stdout,level=logging.DEBUG,format="%(message)s")    


    m = Messenger(apiKey, logging)
    m.setup()
    print("connected") 
    def dummy(*args):
        pass
    m.register("dummy/event", dummy)    
    m.heartbeat()

